import{_ as s,o as n,c as a,a as t}from"./app-c399b13a.js";const e={},c=t(`<h3 id="_1-socket概念" tabindex="-1"><a class="header-anchor" href="#_1-socket概念" aria-hidden="true">#</a> 1. socket概念</h3><p><img src="https://static.mittacy.com/blog/20190718154523875.png" alt="socket与应用层和运输层、网络层关系"></p><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><h3 id="_2-socket基本操作" tabindex="-1"><a class="header-anchor" href="#_2-socket基本操作" aria-hidden="true">#</a> 2. socket基本操作</h3><h4 id="_2-1-socket" tabindex="-1"><a class="header-anchor" href="#_2-1-socket" aria-hidden="true">#</a> 2.1 socket()</h4><p>socket(int domain, int type, int protocol)</p><p>用于创建一个socket描述符（socket descriptor），它唯一标识一个socket</p><ul><li><p>domain <strong>协议域</strong>，协议族决定了socket的地址类型，在通信中必须采用对应的地址</p><p>常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等</p></li><li><p>type <strong>指定socket类型</strong>，常用的有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等</p></li><li><p>protocol <strong>协议</strong>，常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等</p></li></ul><h4 id="_2-3-bind" tabindex="-1"><a class="header-anchor" href="#_2-3-bind" aria-hidden="true">#</a> 2.3 bind()</h4><p>bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)</p><p>把一个地址族中的特定地址赋给 socket</p><ul><li><p>sockfd socket描述字，通过socket()函数创建</p></li><li><p>addr 指向要绑定给 sockfd 的协议地址，这个地址结果根据地址创建 socket 时的地址<strong>协议族</strong>的不同而不同</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// ipv4</span>
<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> <span class="token punctuation">{</span>
  <span class="token class-name">sa_family_t</span> 		sin_family<span class="token punctuation">;</span>
  <span class="token class-name">in_port_t</span> 			sin_port<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">in_addr</span>	sin_addr<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">in_addr</span> <span class="token punctuation">{</span>
  <span class="token class-name">uint32_t</span>	s_addr<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// ipv6</span>
<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in6</span> <span class="token punctuation">{</span> 
    <span class="token class-name">sa_family_t</span>     sin6_family<span class="token punctuation">;</span>    
    <span class="token class-name">in_port_t</span>       sin6_port<span class="token punctuation">;</span>      
    <span class="token class-name">uint32_t</span>        sin6_flowinfo<span class="token punctuation">;</span>  
    <span class="token keyword">struct</span> <span class="token class-name">in6_addr</span> sin6_addr<span class="token punctuation">;</span>      
    <span class="token class-name">uint32_t</span>        sin6_scope_id<span class="token punctuation">;</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">in6_addr</span> <span class="token punctuation">{</span> 
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span>   s6_addr<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>addrlen 地址的长度</p></li></ul><h4 id="_2-4-listen" tabindex="-1"><a class="header-anchor" href="#_2-4-listen" aria-hidden="true">#</a> 2.4 listen()</h4><p>int listen(int sockfd, int backlog);</p><p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket</p><ul><li>sockfd socket描述字</li><li>backlog 相应socket可以排队的最大连接个数</li></ul><h4 id="_2-5-accept" tabindex="-1"><a class="header-anchor" href="#_2-5-accept" aria-hidden="true">#</a> 2.5 accept()</h4><ol><li>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了</li><li>TCP客户端依次调用socket()、connect()之后就向TCP服务器发送了一个连接请求</li><li>TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>sockfd 服务器的socket描述字</li><li>addr 指向struct sockaddr *的指针，用于返回客户端的协议地址</li><li>addrlen 协议地址的长度</li></ul><p>如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接</p><p>注意：accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept() 返回的事已连接的socket描述字。</p><p>一个服务器通常仅仅只创建了一个已连接socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接收的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就关闭</p><h4 id="_2-6-connect" tabindex="-1"><a class="header-anchor" href="#_2-6-connect" aria-hidden="true">#</a> 2.6 connect()</h4><p>客户端调用connect()发出连接请求，服务器端就会接收到这个请求。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>sockfd 客户端socket描述字</li><li>*addr 服务器的scoket地址</li><li>addrlen socket地址的长度</li></ul><h4 id="_2-7-read-write" tabindex="-1"><a class="header-anchor" href="#_2-7-read-write" aria-hidden="true">#</a> 2.7 read()/write()</h4><p>至此，服务器与客户已经建立好连接了。可以调用I/O进行读写操作了，即实现了网络中不同进程之间的通信</p><p>网络I/O操作有：</p><ul><li>read()/write()</li><li>recv()/send()</li><li>readv()/writev()</li><li>recvmsg()/sendmsg()</li><li>recvfrom()/sendto()</li></ul><p>推荐使用<code>recvmsg()/sendmsg()</code>函数，这两个函数是最通用的I/O函数，实际上可以把上面的其它函数都替换成这两个函数</p><p>函数声明如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token class-name">ssize_t</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ssize_t</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">ssize_t</span> <span class="token function">recv</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ssize_t</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">ssize_t</span> <span class="token function">recvfrom</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>src_addr<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> <span class="token operator">*</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ssize_t</span> <span class="token function">sendto</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> 
								<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>dest_addr<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">ssize_t</span> <span class="token function">recvmsg</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">msghdr</span> <span class="token operator">*</span>msg<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ssize_t</span> <span class="token function">sendmsg</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">msghdr</span> <span class="token operator">*</span>msg<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>read函数是负责从fd中读取内容</p><ul><li>当读成功时，read返回实际所读的字节数</li><li>如果返回的值是0表示已经读到文件的结束了</li><li>小于0表示出现了错误 <ul><li>如果错误为EINTR说明读是由中断引起的</li><li>如果是ECONNREST表示网络连接出了问题</li></ul></li></ul><p>write函数将buf中的nbytes字节内容写入文件描述符fd</p><ul><li>成功，返回写的字节数</li><li>失败时返回-1，并设置errno变量</li></ul><p>在网络程序中，当我们向套接字文件描述符写时有俩种可能</p><ul><li>write的返回值大于0，表示写了部分或者是 全部的数据</li><li>返回的值小于0，此时出现了错误 <ul><li>如果错误为EINTR表示在写的时候出现了中断错误</li><li>如果为EPIPE表示 网络连接出现了问题(对方已经关闭了连接)</li></ul></li></ul><h4 id="_2-8-close" tabindex="-1"><a class="header-anchor" href="#_2-8-close" aria-hidden="true">#</a> 2.8 close()</h4><p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数</p><p><strong>注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求</strong></p><h3 id="_3-tcp三次握手与socket" tabindex="-1"><a class="header-anchor" href="#_3-tcp三次握手与socket" aria-hidden="true">#</a> 3. tcp三次握手与socket</h3><p><img src="https://static.mittacy.com/blog/Snipaste_2020-09-04_12-51-27.jpg" alt="tcp三握手"></p><ol><li>客户端调用 connect()出发连接请求，向服务器发送了 SYN J包，connect 进入阻塞状态；</li><li>服务器监听到连接请求，即受到 SYN J包，调用 accept() 接收请求向客户端发送 SYN K、ACK J+1，accpet() 进入阻塞状态；</li><li>客户端受到服务器的 SYN K、ACK J+1后，这时 connect() 返回，并对 SYN K进行确认；</li><li>服务器受到 ACK K+1时，accept() 返回，至此三次握手完毕，连接建立</li></ol><h3 id="_4-tcp四次挥手与scoket" tabindex="-1"><a class="header-anchor" href="#_4-tcp四次挥手与scoket" aria-hidden="true">#</a> 4. tcp四次挥手与scoket</h3><p><img src="https://static.mittacy.com/blog/Snipaste_2020-09-04_12-59-20.jpg" alt="四次挥手"></p><ol><li>某个应用进程首先条用 close() 主动关闭连接，这时 TCP 发送一个 FIN M；</li><li>服务端接收到 FIN M 之后，执行被动关闭，对这个 FIN 进行确认。它的接收也作为文件结束符传递给应用进程，因为 FIN 的接收意味着应用进程在相应的连接上再也不用接收数据</li><li>接收到文件结束符的应用 发送完剩余数据后，调用 close() 关闭它的 socket，发送一个 FIN N；</li><li>接收到这个 FIN 的源发送端 TCP 对它进行确认</li></ol><hr><p>参考链接：</p><p>https://blog.csdn.net/pashanhu6402/article/details/96428887</p>`,54),p=[c];function o(l,i){return n(),a("div",null,p)}const k=s(e,[["render",o],["__file","index.html.vue"]]);export{k as default};

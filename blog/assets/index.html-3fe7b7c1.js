import{_ as e,o as a,c as s,a as t}from"./app-c399b13a.js";const o={},r=t(`<p><strong>跨域请求</strong>：当前发起请求的域与该请求指向的资源所在的域不一样</p><p>(域：认为若协议 + 域名 + 端口号均相同就是同域)</p><p>比如我的博客blog.mittacy.com, 发起了blog.mittacy.com/api/admin的Ajax请求，这个请求就是同域的；</p><p>相反，如果发起了www.baidu.com/....的请求就是跨域请求</p><h3 id="_1-跨域安全问题" tabindex="-1"><a class="header-anchor" href="#_1-跨域安全问题" aria-hidden="true">#</a> 1.跨域安全问题</h3><p>​ 大多数浏览器都会跨域请求作出限制，这是从浏览器层面上的一种安全防御</p><h4 id="csrf攻击" tabindex="-1"><a class="header-anchor" href="#csrf攻击" aria-hidden="true">#</a> CSRF攻击</h4><p>​ CSRF(Cross-site request forgery) 跨站请求伪造</p><p>​ 可以这么理解CSRF攻击：<strong>攻击者盗用了你的身份，以你的名义发送恶意请求</strong>。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账......造成的问题包括：个人隐私泄露以及财产安全</p><p><strong>原理</strong></p><p>​ 有两个网站，其中A网站是真实受信任的网站，而B网站是危险网站</p><p>​ 在用户登陆了受信任的A网站时，本地会存储A网站相关的Cookie，并且浏览器也维护这一个Session会话。这时，如果用户在没有登出A网站的情况下访问危险网站B，那么危险网站B就可以模拟发出一个对A网站的请求（跨域请求）对A网站进行操作，而在A网站的角度来看是并不知道请求是由B网站发出来的（Session和Cookie均为A网站的），这时便成功发动一次CSRF 攻击。</p><h3 id="_2-同源策略" tabindex="-1"><a class="header-anchor" href="#_2-同源策略" aria-hidden="true">#</a> 2.同源策略</h3><p><strong>同源</strong>：域名、协议、端口有一个不同就不是同源，三者均相同，这两个网站才是同源</p><p>支持JavaScript的浏览器都使用同源策略</p><ul><li>禁止Ajax直接发起跨域http请求(实际上发送了请求，只是结果被浏览器拦截)</li><li>Ajax请求不能携带与本站不同源的Cookie</li><li><code>&lt;img&gt;&lt;iframe&gt;&lt;link&gt;&lt;video&gt;&lt;audio&gt;</code>等带有src属性的标签可以从不同的域加载和执行资源</li><li><code>flash、java applet、silverlight、googlegears</code>等浏览器加载的第三方插件也有各自的同源策略，只是这些同源策略不属于浏览器原生的同源策略，如果有漏洞则可能被黑客利用，从而留下XSS攻击的后患</li></ul><h3 id="_3-如何跨域" tabindex="-1"><a class="header-anchor" href="#_3-如何跨域" aria-hidden="true">#</a> 3.如何跨域</h3><p>虽然在安全层面上同源限制是必要的，但有时同源策略会对我们的合理用途造成影响，有多种方式可以绕开同源策略</p><h4 id="_3-1-jsonp" tabindex="-1"><a class="header-anchor" href="#_3-1-jsonp" aria-hidden="true">#</a> 3.1 JSONP</h4><p>​ JSONP 是一种非官方的跨域数据交互协议，本质上是利用 <code>&lt;img&gt;&lt;iframe&gt;</code> 等标签不受同源策略限制，可以从不同域加载并执行资源的特性，来实现数据跨域传输</p><p>​ JSONP由两部分组成：回调函数和数据。</p><pre><code>+	回调函数是当响应到来时应该在页面中调用的函数
+	数据就是传入回调函数中的JSON数据
</code></pre><p>过程：</p><p>① 与服务端约定好一个回调函数名</p><p>② 服务端接收到请求后，将返回一段 Javascript，在这段 Javascript 代码中调用了约定好的回调函数，并且将数据作为参数进行传递。</p><p>③ 当网页接收到这段 Javascript 代码后，就会执行这个回调函数，这时数据已经成功传输到客户端了。</p><h4 id="_3-2-cors" tabindex="-1"><a class="header-anchor" href="#_3-2-cors" aria-hidden="true">#</a> 3.2 CORS</h4><p>​ CORS(Cross-Origin Resource Sharing) 是一个新的 W3C 标准，它新增了一组HTTP首部字段，允许服务端其声明哪些源站有权限访问哪些资源。它允许浏览器向声明了 CORS 的跨域服务器，发出 XMLHttpReuest 请求，从而克服 Ajax 只能同源使用的限制。</p><p>​ 对于非简单请求(如POST)，流览器必须首先使用 OPTION 方法发起一个预检请求(preflight request)，从而获知服务端是否允许该跨域请求，在服务器确定允许后，才发起实际的HTTP请求。</p><p><strong>CORS新增首部字段</strong></p><ul><li><p>Access-Control-Allow-Origin 响应首部中可以携带这个头部表示服务器允许哪些域可以访问该资源</p><ul><li><div class="language-jsx line-numbers-mode" data-ext="jsx"><pre class="language-jsx"><code>  Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Origin<span class="token operator">:</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>origin</span><span class="token punctuation">&gt;</span></span><span class="token plain-text"> | *
</span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>origin 参数的值指定了允许访问该资源的外域 URI</p></li></ul></li><li><p>Access-Control-Allow-Methods 该首部字段用于预检请求的响应，指明实际请求所允许使用的HTTP方法</p></li><li><p>Access-Control-Allow-Headers 该首部字段用于预检请求的响应。指明了实际请求中允许携带的首部字段。</p></li><li><p>Access-Control-Max-Age 该首部字段用于预检请求的响应，指定了预检请求能够被缓存多久</p></li><li><p>Access-Control-Allow-Credentials 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie，默认允许</p></li><li><p>Origin 该首部字段表明预检请求或实际请求的源站。不管是否为跨域请求，Origin字段总是被发送</p></li><li><p>Access-Control-Request-Method 该首部字段用于预检请求。其作用是，将实际请求所使用的 HTTP 方法告诉服务器。</p></li><li><p>Access-Control-Request-Headers 该首部字段用于预检请求。其作用是，将实际请求所携带的首部字段告诉服务器。</p></li></ul><p><strong>优点</strong>：支持所有类型的 HTTP 请求，可以是使用普通的 XMLHttpRequest 发起请求和获取数据，比起 JSONP 有更好的错误处理</p><p><strong>缺点</strong>：一些比较老的浏览器不支持</p><hr><p><a href="https://www.jianshu.com/p/f880878c1398" target="_blank" rel="noopener noreferrer">什么是跨域请求以及实现跨域的方案</a></p>`,35),i=[r];function n(p,l){return a(),s("div",null,i)}const d=e(o,[["render",n],["__file","index.html.vue"]]);export{d as default};

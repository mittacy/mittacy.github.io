import{_ as n,o as a,c as s,a as e}from"./app-a6a5d4a7.js";const t={},p=e(`<p>如何实现长网址到短网址，短网址到长网址的映射呢，比如：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>原始网址：https://github.com/wangzheng0822/ratelimiter4j
短网址：http://t.cn/EtR9QEG
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="一-通过哈希算法" tabindex="-1"><a class="header-anchor" href="#一-通过哈希算法" aria-hidden="true">#</a> 一. 通过哈希算法</h2><h3 id="_1-实现" tabindex="-1"><a class="header-anchor" href="#_1-实现" aria-hidden="true">#</a> 1. 实现</h3><p><strong>MurmurHash</strong> 算法，提供了两种长度的哈希值，一种是 32bits，一种是 128bits。为了让最终生成的短网址尽可能短，我们可以选择 32bits 的哈希值。对于开头那个 GitHub 网址，经过 MurmurHash 计算后，得到的哈希值就是 181338494</p><p>再将哈希值 <code>181338494</code> 转化为62进制 <code>cgSqq</code></p><p>最终网址变为：http://t.cn/cgSqq</p><p>哈希算法无法避免的一个问题，就是哈希冲突。尽管 MurmurHash 算法，冲突的概率非常低。</p><p>我们可以给原始网址拼接一串特殊字符，比如“[DUPLICATED]”，然后再重新计算哈希值，两次哈希计算都冲突的概率，显然是非常低的。假设出现非常极端的情况，又发生冲突了，我们可以再换一个拼接字符串，比如“[OHMYGOD]”，再计算哈希值。然后把计算得到的哈希值，跟原始网址拼接了特殊字符串之后的文本，一并存储。</p><h3 id="_2-存储" tabindex="-1"><a class="header-anchor" href="#_2-存储" aria-hidden="true">#</a> 2. 存储</h3><p>可以通过mysql存储原网址和短网址的映射</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">table</span> url <span class="token punctuation">(</span>
  short <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span> <span class="token string">&#39;短网址&#39;</span><span class="token punctuation">,</span>
	source <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">&#39;源网址&#39;</span><span class="token punctuation">,</span>
  <span class="token keyword">primary</span> <span class="token keyword">key</span> <span class="token punctuation">(</span>short<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">key</span> <span class="token identifier"><span class="token punctuation">\`</span>source_idx<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>source<span class="token punctuation">\`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-流程" tabindex="-1"><a class="header-anchor" href="#_3-流程" aria-hidden="true">#</a> 3. 流程</h3><ol><li>当有新的原始网址需要生成短网址的时候，直接将生成的短网址与对应的原始网址存储到数据库 <ul><li>存储成功：没有冲突</li><li>存储失败：不一定是冲突。我们需要进行<code>查询 -&gt; 判断是否原网址相同 -&gt; 相同直接返回短网址 -&gt; 不相同添加特殊字符重新尝试存储</code></li></ul></li><li>访问短网址：到数据库查找对应的原始网址，如果原始网址有拼接特殊字符（这个很容易通过字符串匹配算法找到），我们就先将特殊字符去掉，然后再将不包含特殊字符的原始网址返回给浏览器。</li></ol><p>在<code>第1点中</code>我们还可以把已经生成的短网址，构建成布隆过滤器。</p><p>布隆过滤器是比较节省内存的一种存储结构，长度是 10 亿的布隆过滤器，也只需要 125MB 左右的内存空间。</p><p>当有新的短网址生成的时候，先拿这个新生成的短网址，在布隆过滤器中查找。</p><p>如果查找的结果是不存在，那就说明这个新生成的短网址并没有冲突。这个时候，我们只需要再执行写入短网址和对应原始网页的 SQL 语句就可以了。通过先查询布隆过滤器，总的 SQL 语句的执行次数减少了。</p><h2 id="二-id-生成器生成短网址" tabindex="-1"><a class="header-anchor" href="#二-id-生成器生成短网址" aria-hidden="true">#</a> 二. ID 生成器生成短网址</h2><p>我们可以维护一个 ID 自增生成器。它可以生成 1、2、3…这样自增的整数 ID。当短网址服务接收到一个原始网址转化成短网址的请求之后，它先从 ID 生成器中取一个号码，然后将其转化成 62 进制表示法，拼接到短网址服务的域名后面，就形成了最终的短网址。最后，我们还是会把生成的短网址和对应的原始网址存储到数据库中。</p><p>出现问题：<strong>相同的原始网址可能会对应不同的短网址</strong></p><p>处理：</p><ul><li>不做处理，因为只需要保证用户访问短网址能拿到正确的原网址，但是造成资源浪费</li><li>通过原始网址在数据库查找是否已存在，如果存在直接返回短网址。这种方法需要给原始网址加索引，一方面两个索引会占用更多的存储空间，另一方面索引还会导致插入、删除等操作性能的下降</li></ul><h2 id="三-短网址的用处" tabindex="-1"><a class="header-anchor" href="#三-短网址的用处" aria-hidden="true">#</a> 三. 短网址的用处</h2><ul><li><p>缩短内容长度，在限制字数的社交平台有用</p></li><li><p>便于数据统计</p><p><code>A网址 -&gt; 短连接服务 -&gt; B网址</code></p></li><li><p>简化二维码</p><p>如果链接长度过长，生成的二维码图片过于复杂， 会降低二维码扫描的成功率，缩短后的网址二维码就会清晰容易识别</p></li></ul>`,25),o=[p];function c(i,l){return a(),s("div",null,o)}const d=n(t,[["render",c],["__file","index.html.vue"]]);export{d as default};

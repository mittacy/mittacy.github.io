import{_ as e,o as s,c as a,a as n}from"./app-a6a5d4a7.js";const o={},d=n(`<h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h2><p>不知道你有没有遇到过这些场景：</p><ul><li>有时我们在填写表单时，保存按钮不小心快速点击了两次，表中竟然产生了两条重复的数据，只是id不一样</li><li>在项目中为了解决 <strong>接口超时</strong> 问题，通常会引入 <strong>重试机制</strong>。对于成功的请求响应没能返回成功，导致请求方重复请求，出现重复数据</li><li>mq消费者在读取消息时，处理不当会读取到 <strong>重复消息</strong>，如果处理不好，也会产生重复的数据</li></ul><p>以上这些都是幂等性问题</p><p><strong>接口幂等性</strong> 是指用户对于同一个操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生副作用</p><blockquote><p>在这里顺便说一下，<code>防重设计</code> 和 <code>幂等设计</code>，其实是有区别的。防重设计主要为了避免产生重复数据，对接口返回没有太多要求。而幂等设计除了避免产生重复数据之外，还要求每次请求都返回一样的结果。</p></blockquote><ul><li>insert 操作，这种情况下多次请求，可能会产生重复数据</li><li>update 操作，如果只是单纯的更新数据一般没有问题，如果还涉及到运算和时间，比如 <code>update user set status=status+1 where id = 1;</code> 这种情况下多次请求，可能会导致数据错误</li></ul><h2 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案" aria-hidden="true">#</a> 解决方案</h2><h3 id="_1-insert-前先-select" tabindex="-1"><a class="header-anchor" href="#_1-insert-前先-select" aria-hidden="true">#</a> 1. insert 前先 select</h3><p>在保存数据的接口中，先根据 <code>name</code> 或 <code>code</code> 等 <strong>select</strong> 数据，如果数据已存在，则执行 <code>update</code> 操作，如果不存在，才执行 <strong>insert</strong> 操作</p><p>该方案可能是我们平时在防止产生重复数据时，使用最多的方案。但是该方案不适用于并发场景，在并发场景中，要配合其他方案一起使用，否则同样会产生重复数据。</p><h3 id="_2-加悲观锁" tabindex="-1"><a class="header-anchor" href="#_2-加悲观锁" aria-hidden="true">#</a> 2. 加悲观锁</h3><p>加悲观锁，在同一时刻只允许一个请求获得锁，更新数据，其他的请求则等待。</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>select * from user id=123 for update;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_3-加乐观锁" tabindex="-1"><a class="header-anchor" href="#_3-加乐观锁" aria-hidden="true">#</a> 3. 加乐观锁</h3><p>在表中增加一个<code>timestamp</code>或者<code>version</code>字段，这里以<code>version</code>字段为例</p><p>在更新数据之前先查询一下数据：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> id<span class="token punctuation">,</span> amount<span class="token punctuation">,</span> version <span class="token keyword">from</span> <span class="token keyword">user</span> id<span class="token operator">=</span><span class="token number">123</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果数据存在，假设查到的 <code>version</code> 等于 <code>1</code>，再使用 <code>id</code> 和 <code>version</code> 字段作为查询条件更新数据：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">update</span> <span class="token keyword">user</span> <span class="token keyword">set</span> amount <span class="token operator">=</span> amount<span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">,</span> version <span class="token operator">=</span> version<span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">123</span> <span class="token operator">and</span> version <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第一次请求<code>version</code>等于<code>1</code>是可以成功的，操作成功后<code>version</code>变成<code>2</code>了，如果并发的请求过来，再执行相同的sql，会发现 version=1 没有匹配的，该<code>update</code>操作不会真正更新数据，但为了保证接口幂等性，接口可以直接返回成功。</p><h3 id="_4-加唯一索引" tabindex="-1"><a class="header-anchor" href="#_4-加唯一索引" aria-hidden="true">#</a> 4. 加唯一索引</h3><p>绝大数情况下，为了防止重复数据的产生，我们都会在表中加唯一索引，这是一个非常简单，并且有效的方案。</p><p>加了唯一索引之后，第一次请求数据可以插入成功。但后面的相同请求，插入数据时会报<code>Duplicate entry &#39;002&#39; for key &#39;order.un_code</code>异常，表示唯一索引有冲突，为了保证接口幂等性，我们需要对该异常进行捕获，然后返回成功。</p><h3 id="_5-建防重表" tabindex="-1"><a class="header-anchor" href="#_5-建防重表" aria-hidden="true">#</a> 5. 建防重表</h3><p>有时候表中并非所有的场景都不允许产生重复的数据，只有某些特定场景才不允许，这时候就不能通过在表中直接加唯一索引，显然是不太合适的，针对这种情况可以 <code>建防重表</code> 来解决。</p><p>该表可以只包含两个字段：<code>id</code> 和 <code>唯一索引</code>，唯一索引可以使多个字段组成的唯一标识</p><blockquote><p>需要特别注意的是：防重表和业务表必须在同一个数据库中，并且业务表和防重表的操作要在同一个事务中</p></blockquote><h3 id="_6-状态机" tabindex="-1"><a class="header-anchor" href="#_6-状态机" aria-hidden="true">#</a> 6. 状态机</h3><p>很多时候业务表是有状态的，比如订单表中有：1-下单、2-已支付、3-完成、4-撤销等状态，这些状态的值是有规律的，按照业务节点正好是从小到大，我们就能通过它来保证接口的幂等性。</p><p>假如id=123的订单状态是<code>已支付</code>，现在要变成<code>完成</code>状态：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token operator">&gt;</span> <span class="token keyword">update</span> <span class="token identifier"><span class="token punctuation">\`</span>order<span class="token punctuation">\`</span></span> <span class="token keyword">set</span> <span class="token keyword">status</span><span class="token operator">=</span><span class="token number">3</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">123</span> <span class="token operator">and</span> <span class="token keyword">status</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第一次请求时，该订单的状态是<code>已支付</code>，值是<code>2</code>，所以该<code>update</code>语句可以正常更新数据，后面有相同的请求过来，再执行相同的sql时，由于订单状态变成了<code>3</code>，再用<code>status=2</code>作为条件，无法查询出需要更新的数据，所以最终sql执行结果的影响行数是<code>0</code>，为了保证接口幂等性，影响行数是<code>0</code>时，接口也可以直接返回成功。</p><blockquote><p>主要特别注意的是，该方案仅限于要更新的<code>表有状态字段</code>，并且刚好要更新<code>状态字段</code>的这种特殊情况，并非所有场景都适用</p></blockquote><h3 id="_7-加分布式锁" tabindex="-1"><a class="header-anchor" href="#_7-加分布式锁" aria-hidden="true">#</a> 7. 加分布式锁</h3><p>前面介绍过的 <code>加唯一索引</code> 或者 <code>加防重表</code>，本质是使用了数据库的分布式锁，也属于分布式锁。但由于数据库分布式锁的性能不太好，可以改用 <code>redis</code></p><p>主要有三种方式实现redis的分布式锁：</p><ul><li>setNx命令</li><li>set命令</li><li>Redission框架</li></ul><p>具体步骤：</p><ol><li>用户通过浏览器发起请求，服务端会收集数据，并且生成订单号code作为唯一业务字段</li><li>使用redis的set命令，将该订单code设置到redis中，同时设置超时时间</li><li>判断是否设置成功，如果设置成功，说明是第一次请求，则进行数据操作</li><li>如果设置失败，说明是重复请求，则直接返回成功</li></ol><hr><p><a href="https://mp.weixin.qq.com/s/09CKM9wTMWnbtVgoM9_p2w" target="_blank" rel="noopener noreferrer">高并发下如何保证接口的幂等性</a></p>`,42),c=[d];function r(t,p){return s(),a("div",null,c)}const l=e(o,[["render",r],["__file","index.html.vue"]]);export{l as default};

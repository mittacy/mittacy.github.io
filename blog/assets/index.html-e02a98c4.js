import{_ as a,o as e,c as h,a as r}from"./app-a6a5d4a7.js";const i={},s=r('<h3 id="_1-结构设计" tabindex="-1"><a class="header-anchor" href="#_1-结构设计" aria-hidden="true">#</a> 1. 结构设计</h3><p>散列表(Hash Table) 也叫“哈希表”或者“Hash表”。</p><p>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</p><ul><li>键(Key)或关键字</li><li>散列函数(Hash函数)</li><li>散列值(Hash值)</li></ul><p><img src="https://static.mittacy.com/blog/20200328102417.jpg" alt=""></p><p>​ 我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据</p><p>散列函数设计的基本要求：</p><ul><li>散列函数计算得到的散列值是一个非负整数；</li><li>如果 key1 = key2，那 hash(key1) == hash(key2)；</li><li>如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)</li></ul><p>在真实的情况下，要想找到一个不同的 key 对应的散列值都不一样的散列函数，几乎是不可能的。即便像业界著名的MD5、SHA、CRC等哈希算法，也无法完全避免这种<strong>散列冲突</strong>。</p><h3 id="_2-散列冲突" tabindex="-1"><a class="header-anchor" href="#_2-散列冲突" aria-hidden="true">#</a> 2. 散列冲突</h3><p>再好的散列函数也无法避免散列冲突</p><p><strong>装载因子</strong>：<code>散列表的装载因子 = 填入表中的元素个数 / 散列表的长度</code></p><p>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</p><p>我们常用的散列冲突解决方法有两类：</p><ul><li>链表法（chaining）</li><li>开放寻址法（open addressing） <ul><li>线性探测</li><li>二次探测</li><li>双重散列</li></ul></li></ul><h4 id="_2-1-线性探测" tabindex="-1"><a class="header-anchor" href="#_2-1-线性探测" aria-hidden="true">#</a> 2.1 线性探测</h4><p>存储：键通过散列函数计算出来的散列值到数组中相应位置，如果该位置已经存在数据了，即发生了散列冲突，顺序地往后一个一个找，看有没有空闲的位置，遍历到尾部都没有找到空闲的位置，于是我们再从表头开始找，直到找到空闲位置</p><p>查找：键通过散列函数计算出来的散列值到数组中相应位置，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。</p><h4 id="_2-2-二次探测" tabindex="-1"><a class="header-anchor" href="#_2-2-二次探测" aria-hidden="true">#</a> 2.2 二次探测</h4><p>所谓二次探测，跟线性探测很像，线性探测每次探测的步长是 1，而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0，hash(key)+1^2，hash(key)+2^2……</p><h4 id="_2-3-双重散列" tabindex="-1"><a class="header-anchor" href="#_2-3-双重散列" aria-hidden="true">#</a> 2.3 双重散列</h4><p>所谓双重散列，意思就是不仅要使用一个散列函数。我们使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</p><h4 id="_2-4-链表法" tabindex="-1"><a class="header-anchor" href="#_2-4-链表法" aria-hidden="true">#</a> 2.4 链表法</h4><p>链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中</p><p><strong>存储</strong>：键通过散列函数计算出来的散列值到数组中相应位置，将其插入到对应链表中即可</p><p><strong>查找</strong>：键通过散列函数计算出来的散列值到数组中相应位置，然后遍历链表查找</p><h3 id="_3-扩容机制" tabindex="-1"><a class="header-anchor" href="#_3-扩容机制" aria-hidden="true">#</a> 3. 扩容机制</h3><p>链表法不会有容量的限制，但是线性探测和二次探测如果初始容量小的话，很容易就满了需要进行扩容</p><p><strong>Java中的实现</strong></p><p>​ 首先是，每次扩容时，哈希表的<strong>容量增加为原先的两倍</strong>。于是在扩容被触发时（实际装载因子达到默认装载因子时），需要对原先的表进行rehash。所以这时增加一个元素的性能是比较差的，因为要等待原先的表rehash之后才能增加该元素</p><p><strong>Redis中的实现</strong></p><p><strong>均摊思想</strong></p><p>​ 采取的是<strong>分摊转移</strong>的方式。即当插入一个新元素触发了扩容时，先转移第一个不为空的桶到新的哈希表，然后将该元素插入。而下一次再次插入时，继续转移旧哈希表中第一个不为空的桶，再插入元素。直至旧哈希表为空为止。这样一来，理想情况下，插入的时间复杂度是O(1)</p><h3 id="_4-应用场景" tabindex="-1"><a class="header-anchor" href="#_4-应用场景" aria-hidden="true">#</a> 4. 应用场景</h3><p>散列表的应用场景太多了，比如Go语言的Map底层就用到了散列表，可以研究一下，<a href="https://blog.mittacy.com/article/30" target="_blank" rel="noopener noreferrer">Go是如何实现Map的</a></p>',35),t=[s];function n(p,l){return e(),h("div",null,t)}const d=a(i,[["render",n],["__file","index.html.vue"]]);export{d as default};
